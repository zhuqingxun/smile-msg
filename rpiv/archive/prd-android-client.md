---
description: "产品需求文档: android-client"
status: archived
created_at: 2026-01-30T15:00:00
updated_at: 2026-01-30T22:00:00
archived_at: 2026-01-30T22:00:00
---

# SmileMsg Android 客户端 产品需求文档

## 1. 执行摘要

SmileMsg 是一个"阅后即焚"即时通讯工具，目前已覆盖 Web 和 Windows Desktop 两个平台。本项目的目标是将 SmileMsg 扩展到 Android 平台，让手机用户也能使用阅后即焚通讯能力。

Android 客户端将复用现有的 SmileMsg 服务端（Node.js + Socket.io），无需服务端改动。客户端功能与 Web 端完全一致，但 UI 将针对移动端重新设计，符合 Android 原生操作习惯。分发方式为 APK 侧载，不上架应用市场。

**MVP 目标**：交付一个功能完整、体验良好的 Android APK，具备登录、输入对方昵称发起私聊、阅后即焚消息收发等全部核心功能，并针对移动端特性实现自动重连、振动反馈和状态栏通知。

## 2. 使命

**使命声明**：将 SmileMsg 阅后即焚通讯能力扩展到 Android 移动端，让用户在手机上也能安全、便捷地进行即时通讯。

**核心原则：**

1. **功能对等**：Android 端与 Web 端功能完全一致，用户在任一平台的体验不打折扣
2. **连接优先**：用户未主动断开就尽力保持连接，最大程度减少"意外掉线"感知
3. **移动端原生体验**：UI 针对触屏和移动场景重新设计，不是简单的 WebView 套壳
4. **极简分发**：APK 侧载即用，不依赖应用市场审核流程

## 3. 目标用户

### 主要用户角色

- **SmileMsg 现有用户中的 Android 手机用户**：已经在 Web 或 Desktop 端使用 SmileMsg，希望在手机上也能与其他用户通讯
- **移动优先用户**：主要通过手机上网，Web/Desktop 端使用不便

### 技术舒适度

- 能够手动安装 APK（侧载），熟悉"允许安装未知来源应用"操作
- 不需要高级技术能力

### 关键用户需求和痛点

- **痛点**：外出时无法使用 SmileMsg，只能等回到电脑前
- **需求**：在手机上随时随地发起和参与阅后即焚聊天
- **期望**：切换到其他 App 或锁屏后不会轻易断线丢失会话

## 4. MVP 范围

### 范围内

**核心功能：**
- ✅ 登录功能：输入昵称 + 自动生成 UUID 连接服务器
- ✅ 手动发起私聊：在 idle 页面输入对方昵称发起一对一私聊（同一用户同时只能参与一个会话）
- ✅ 文本消息收发：发送和接收文本消息，阅后即焚
- ✅ 连接状态显示：UI 实时反映连接/断开状态
- ✅ 对方离线通知：对方断线时显示系统提示

**移动端特性：**
- ✅ 重新设计的移动端 UI：符合 Android 操作习惯的全新界面
- ✅ 回车键发送消息：软键盘回车键直接发送
- ✅ 振动反馈：前台收到消息时手机振动提示
- ✅ 状态栏通知：后台保活期间收到消息发状态栏通知
- ✅ 横竖屏支持：支持自动旋转，竖屏和横屏均可使用

**连接管理：**
- ✅ 自动重连：网络切换（WiFi ↔ 移动数据）后自动重连，用户无感（依赖 Socket.io 内置重连机制）
- ✅ 进程恢复：进程被系统杀死后再次打开，自动用持久化的 UUID 和昵称尝试重连恢复会话
- ✅ 主动退出清理：用户主动退出时清除持久化数据，下次打开回到登录页

**分发：**
- ✅ APK 侧载：构建产出 APK 文件，用户手动安装

### 范围外

- ❌ 后台消息推送通知（FCM 等，App 被系统彻底杀死后无法收到消息）
- ❌ 图片/文件/多媒体消息发送（仅支持文本）
- ❌ 消息复制功能（长按复制等，符合阅后即焚理念）
- ❌ 应用市场上架（Google Play 等）
- ❌ 昵称自动填充（仅在进程恢复场景下持久化，用户主动退出后不保留）
- ❌ 服务器地址配置（内置固定的 Zeabur 生产地址）
- ❌ 国际化/多语言（仅中文）
- ❌ 深色模式（如果时间允许可附带，但不作为 MVP 要求）
- ❌ 服务端改动（完全复用现有服务端）

## 5. 用户故事

### 主要用户故事

**US-1：移动端登录**
> 作为 SmileMsg 用户，我想要在 Android 手机上打开 App 并输入昵称登录，以便在手机上使用阅后即焚通讯。

示例：用户安装 APK 后打开 App，看到登录页，输入昵称"小明"，点击登录，进入 idle 页面（显示输入框可输入对方昵称发起聊天）。

**US-2：发起私聊**
> 作为已登录用户，我想要输入对方的昵称发起聊天，以便开始一对一的阅后即焚对话。

示例：用户在 idle 页面的输入框中输入"小红"，点击发起聊天按钮，双方进入聊天界面。

**US-3：消息收发**
> 作为聊天中的用户，我想要发送和接收文本消息，以便与对方即时交流。

示例：用户在输入框输入"你好"，按回车键或点击发送按钮，消息立即出现在聊天界面；对方发送的消息也实时显示。

**US-4：后台保持连接**
> 作为正在聊天的用户，我想要切换到其他 App 后仍然保持连接，以便回来时不需要重新登录。

示例：用户正在和小红聊天，切到微信回复了一条消息，切回 SmileMsg 时聊天会话仍在，没有任何断线提示。

**US-5：进程恢复**
> 作为正在聊天的用户，即使 App 被系统杀死，我再次打开时也希望能自动恢复会话，以便不打断对话。

示例：系统因内存不足杀死了 SmileMsg 进程，用户重新打开 App 后自动用之前的昵称重连，如果对方还在线则直接恢复聊天界面。

**US-6：新消息提醒**
> 作为正在聊天的用户，我想要收到新消息时有触觉和视觉提醒，以便不错过消息。

示例：App 在前台时收到消息手机振动；App 在后台时收到消息状态栏弹出通知。

**US-7：主动退出**
> 作为用户，我想要主动退出后彻底清除会话状态，以便下次以全新身份登录。

示例：用户点击退出按钮，App 断开连接并清除所有本地数据，回到登录页。下次打开 App 时显示空白的昵称输入框。

### 技术用户故事

**TUS-1：网络切换自动重连**
> 作为开发者，我需要 App 在 WiFi 和移动数据之间切换时自动重连 Socket，以便用户无感地保持通讯。

## 6. 核心架构与模式

### 高级架构方法

Android 客户端作为 SmileMsg 生态的新平台端，与现有服务端通过 Socket.io 协议通信。架构上与 Web/Desktop 端处于同一层级：

```
┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│   Web 端    │  │ Desktop 端  │  │ Android 端  │
│  (Vue+Vite) │  │ (Electron)  │  │  (原生App)  │
└──────┬──────┘  └──────┬──────┘  └──────┬──────┘
       │                │                │
       └────────────────┼────────────────┘
                        │ Socket.io
                 ┌──────┴──────┐
                 │   Server    │
                 │(Node+Express│
                 │ +Socket.io) │
                 └─────────────┘
```

### 关键设计模式

- **通信协议对齐**：使用与 Web 端完全相同的 Socket.io 事件协议（`login`、`create_private_chat`、`send_message` 等），无需服务端改动
- **UUID 恢复机制**：复用服务端已有的 UUID 断线恢复逻辑（`registerUser` 中的重连检测）
- **状态机模式**：与 Web 端一致的 phase 状态机（`login` → `idle` → `chat`）
- **本地持久化策略**：区分主动退出（清除数据）和被动中断（保留数据用于恢复）

### 现有服务端协议（Android 端必须对齐）

| 事件名 | 方向 | 用途 |
|--------|------|------|
| `login` | Client → Server | 登录/重连，携带 uuid + nickname |
| `create_private_chat` | Client → Server | 发起一对一私聊 |
| `send_message` | Client → Server | 发送消息 |
| `new_message` | Server → Client | 接收新消息 |
| `conversation_created` | Server → Client | 会话创建通知 |
| `peer_offline` | Server → Client | 对方离线通知 |
| `force_disconnect` | Server → Client | 强制断开通知 |

## 7. 功能规范

### 7.1 登录模块

**功能描述**：用户输入昵称，App 生成 UUID，通过 Socket.io 连接服务器并注册。

**输入**：昵称（字符串，非空，去除首尾空格）

**输出**：登录成功进入 idle 页面（可输入对方昵称发起聊天），或显示错误信息

**业务规则**：
- 每次用户主动退出后重新打开 App，都需要重新输入昵称
- 进程被系统杀死后重新打开，如果本地有持久化数据则自动尝试恢复
- 昵称已被占用时提示错误，需重新输入
- 登录过程中显示加载状态

### 7.2 发起私聊（idle 页面）

**功能描述**：用户在 idle 页面通过手动输入对方昵称来发起一对一私聊。

**交互**：
- 页面显示一个昵称输入框和"发起聊天"按钮
- 用户输入对方昵称后点击按钮（或按回车键）发起私聊请求
- 对方昵称不存在或不在线时显示错误提示
- 对方正在聊天中时显示"对方正在聊天中"错误提示

> 注意：与 Web/Desktop 端完全一致，SmileMsg 没有在线用户列表功能。用户必须知道对方的昵称才能发起聊天，这是该产品的核心设计特点。

### 7.3 聊天模块

**功能描述**：一对一文本消息收发，阅后即焚。

**交互流程**：
1. 在 idle 页面输入对方昵称 → 发起私聊请求
2. 双方进入聊天界面
3. 底部输入框 + 发送按钮，回车键发送
4. 消息气泡展示（区分自己/对方）
5. 系统消息展示（对方离线等）
6. 对方离线后聊天界面显示提示，用户可返回 idle 页面

**业务规则**：
- 同一用户同时只能参与一个会话
- 不支持消息复制（长按无响应）
- 消息列表最多保留 200 条（与 Web 端一致）
- 对方正在聊天中时，发起请求应提示不可用

### 7.4 连接管理

**功能描述**：管理 Socket.io 连接的建立、维持、断线重连。

**自动重连策略**：
- 网络切换（WiFi ↔ 移动数据）时自动重连
- 重连成功后自动重新 login（携带原 UUID），服务端恢复会话状态
- 重连参数：无限重试，初始延迟 1 秒，最大延迟 5 秒（与 Web 端一致）

**UI 反馈**：
- 连接断开时界面显示断线状态指示
- 重连中显示"正在重连..."状态
- 重连成功自动恢复，用户无感

### 7.5 App 生命周期管理

**后台行为**：
- App 切到后台时依赖 Socket.io 内置重连机制维持连接
- MVP 不使用前台服务（Foreground Service）保活，后台连接可能被系统回收
- 如果后台连接断开，回到前台时 Socket.io 自动重连并恢复会话

**进程恢复**：
- 本地持久化存储：UUID、昵称、是否处于聊天状态
- 进程被杀后再次打开：读取持久化数据 → 自动用原 UUID 和昵称登录 → 服务端返回恢复结果
  - 恢复成功（对方仍在线）：直接进入聊天界面
  - 恢复失败（对方已离开或会话已结束）：进入 idle 状态
  - 登录失败（昵称已被新用户占用等）：回到登录页

**主动退出**：
- 用户点击退出按钮 → 断开 Socket → 清除本地持久化数据（UUID、昵称）→ 显示登录页
- 下次打开 App 从空白登录页开始

### 7.6 通知与反馈

**振动反馈**：
- App 在前台且聊天界面收到新消息时触发短振动

**状态栏通知**：
- App 在后台且连接仍存活时，收到新消息发状态栏通知
- 点击通知回到 App 聊天界面

## 8. 技术栈

### 现有服务端（不变）
- **运行时**：Node.js
- **框架**：Express 4.21 + Socket.io 4.8
- **存储**：纯内存 Map（无数据库）
- **部署**：Zeabur PaaS

### Android 客户端（新增）
- **最低版本**：Android 10（API 29）
- **Socket 通信**：Socket.io Android 客户端库
- **本地持久化**：SharedPreferences（存储 UUID、昵称等轻量数据）
- **后台保活**：MVP 不使用前台服务，依赖 Socket.io 自动重连
- **通知**：Android NotificationManager + NotificationChannel
- **具体技术方案**：在 plan-feature 阶段确定（原生 Kotlin/Java 或跨平台框架如 Capacitor/React Native 等）

> 注：具体的技术选型（原生 vs 跨平台）将在 plan-feature 阶段根据团队技术栈和项目约束做出决策，此处 PRD 仅描述功能需求，不限定技术方案。

## 9. 安全与配置

### 身份验证
- 与 Web/Desktop 端一致：UUID + 昵称方式，无账号密码体系
- UUID 客户端生成，用于断线恢复身份识别

### 配置
- 服务器地址：内置硬编码 `https://smile-msg.zeabur.app`，不提供用户配置入口
- 无其他环境变量或配置项

### 安全范围
- **范围内**：
  - APK 签名（防止篡改）
  - 通讯使用 WSS（WebSocket Secure）加密传输
- **范围外**：
  - 端到端加密（不在 MVP 范围）
  - 消息本地加密存储（阅后即焚，本地不持久化消息内容）
  - Root 检测、反调试等加固手段

### 部署
- APK 文件直接分发，用户手动安装
- 无自动更新机制（用户手动下载新版本覆盖安装）

## 10. API 规范

Android 客户端不引入新的 API，完全复用现有 Socket.io 事件协议。

### Socket.io 事件详细规范

**`login`（Client → Server）**
```json
// 请求
{ "uuid": "550e8400-...", "nickname": "小明" }

// 回调响应（成功，首次登录）
{ "success": true, "restored": false }

// 回调响应（成功，断线恢复）
{ "success": true, "restored": true, "conversationId": "conv_xxx", "target": { "nickname": "小红" } }

// 回调响应（失败）
{ "success": false, "error": "昵称已被使用" }
```

**`create_private_chat`（Client → Server）**
```json
// 请求
{ "targetNickname": "小红" }

// 回调响应（成功）
{ "success": true, "conversationId": "conv_xxx", "target": { "nickname": "小红" } }

// 回调响应（失败）
{ "success": false, "error": "对方正在聊天中" }
```

**`send_message`（Client → Server）**
```json
{ "conversationId": "conv_xxx", "content": "你好" }
```

**`new_message`（Server → Client）**
```json
{ "conversationId": "conv_xxx", "message": { "id": "msg_xxx", "sender": "小红", "content": "你也好", "timestamp": 1706000000000 } }
```

**`conversation_created`（Server → Client）**
```json
{ "conversationId": "conv_xxx", "target": { "nickname": "小明" } }
```

**`peer_offline`（Server → Client）**
```json
{ "conversationId": "conv_xxx" }
```

**`force_disconnect`（Server → Client）**
无负载，收到后客户端需断开并重置状态。

## 11. 成功标准

### MVP 成功定义

Android 客户端发布后，用户能够在手机上完成与 Web 端完全一致的阅后即焚通讯体验。

### 功能要求
- ✅ 用户可以输入昵称登录
- ✅ 用户可以输入对方昵称发起一对一私聊
- ✅ 用户可以收发文本消息
- ✅ 消息阅后即焚（不持久化）
- ✅ App 切后台时依赖 Socket.io 重连机制（不使用前台服务）
- ✅ 网络切换自动重连
- ✅ 进程被杀后可自动恢复会话
- ✅ 前台收消息振动提示
- ✅ 后台收消息状态栏通知
- ✅ 支持横竖屏

### 质量指标
- Socket 连接建立成功率 > 95%（在网络正常条件下）
- 消息发送到对方接收延迟 < 500ms（在网络正常条件下）
- App 冷启动到登录页显示 < 2 秒
- 回到前台后自动重连成功率 > 90%（网络正常条件下）

### 用户体验目标
- 登录流程操作步骤 ≤ 2 步（输入昵称 + 点击登录）
- 聊天界面布局清晰，消息区域占据主要空间
- 所有加载和错误状态都有明确的 UI 反馈
- 网络切换重连过程用户无感（自动完成，无需手动操作）

## 12. 实施阶段

### 阶段 1：基础框架搭建

**目标**：建立 Android 项目骨架，跑通基础的 Socket.io 连接。

**交付物**：
- ✅ Android 项目初始化（包结构、构建配置）
- ✅ Socket.io 客户端集成，能连接服务器
- ✅ 登录页 UI + 登录逻辑
- ✅ 基础导航框架（登录页 ↔ 主页面）

**验证标准**：能在模拟器或真机上运行 App，输入昵称成功登录到服务端。

### 阶段 2：核心功能实现

**目标**：完成全部聊天功能，达到与 Web 端功能对等。

**交付物**：
- ✅ idle 页面（输入对方昵称发起聊天）
- ✅ 聊天界面 UI（消息气泡、输入框、发送按钮）
- ✅ 消息收发功能
- ✅ 对方离线/系统消息展示
- ✅ 断线自动重连 + 会话恢复

**验证标准**：两台设备（或模拟器 + 真机）能完整完成登录 → 发起聊天 → 消息往返 → 断线重连 → 一方退出的全流程。

### 阶段 3：移动端增强

**目标**：完成所有移动端特有功能，打磨体验。

**交付物**：
- ✅ 进程恢复（本地持久化 + 自动重连）
- ✅ 主动退出逻辑（清除持久化数据）
- ✅ 振动反馈
- ✅ 状态栏通知（后台收到新消息时弹通知）
- ✅ 横竖屏适配

**验证标准**：App 切后台 → 收消息弹通知 → 点击通知回到 App → 会话正常；杀进程后重新打开能自动恢复。

### 阶段 4：打包与分发

**目标**：构建可分发的 APK，完成上线准备。

**交付物**：
- ✅ APK 签名配置（使用 debug 签名，不上架应用市场无需 release 签名）
- ✅ Debug 构建产出 APK
- ✅ 构建脚本集成到 monorepo（`pnpm build:android` 或类似命令）
- ✅ App 图标（从 desktop/resources/icon.ico 转换）

**验证标准**：debug 签名的 APK 可在 Android 10+ 真机上正常安装和使用全部功能。

## 13. 未来考虑

### MVP 后增强
- **后台消息推送**：集成 FCM 或其他推送服务，App 被系统彻底杀死后仍能收到消息通知
- **深色模式**：跟随系统主题切换
- **消息类型扩展**：图片、文件、语音消息
- **自动更新**：应用内检测新版本并提示更新

### 集成机会
- **iOS 客户端**：进一步扩展到 iOS 平台
- **消息已读回执**：通知发送方消息已被阅读
- **端到端加密**：增强通讯安全性

### 后期高级功能
- **群聊支持**：多人阅后即焚聊天
- **消息定时销毁**：设定消息自动销毁时间
- **屏幕截图检测**：检测并通知对方截屏行为

## 14. 风险与缓解措施

| 风险 | 影响 | 缓解策略 |
|------|------|----------|
| **Android 后台保活受限**：不同厂商的 Android 系统对后台保活策略差异大，部分厂商会积极杀后台 | 后台连接可能被系统中断 | MVP 不做前台服务保活，依赖 Socket.io 自动重连 + 本地持久化恢复机制；进程被杀后通过持久化数据自动恢复；后续如需求强烈可引入前台服务方案 |
| **Socket.io 客户端兼容性**：Socket.io 的 Android 客户端库可能与服务端版本有兼容问题 | 连接不稳定或无法建立 | 在技术选型阶段验证 Socket.io 客户端库与服务端 4.8 版本的兼容性；准备降级方案（直接使用 WebSocket） |
| **APK 侧载门槛**：用户需要手动允许安装未知来源应用 | 部分用户可能放弃安装 | 提供清晰的安装指引文档 |
| **网络切换丢消息**：WiFi ↔ 移动数据切换瞬间可能丢失消息 | 用户错过消息 | Socket.io 内置的重连机制会在连接恢复后自动 re-login；阅后即焚场景下消息本身不持久化，可接受短暂中断 |
| **跨平台技术选型风险**：如果选择跨平台框架，可能在前台服务、通知等原生功能上遇到限制 | 部分移动端特性可能无法完美实现 | 在 plan-feature 阶段充分评估技术方案对原生能力的支持程度；必要时选择原生开发 |

## 15. 附录

### 相关文档
- 项目 CLAUDE.md：`D:\CODE\smile-msg\CLAUDE.md`
- 服务端数据结构：`server/src/store.js`
- Web 端核心逻辑：`web/src/composables/useSocket.js`（Android 端需对齐的通信协议参考）
- Desktop 端核心逻辑：`desktop/src/renderer/src/composables/useSocket.js`

### 仓库结构

```
smile-msg/
├── server/          # Node.js 服务端（不变）
├── web/             # Vue 3 Web 客户端
├── desktop/         # Electron 桌面客户端
├── android/         # 🆕 Android 客户端（新增）
└── package.json     # monorepo 根配置
```

### 关键依赖
- 服务端：Express 4.21 + Socket.io 4.8
- 部署平台：Zeabur（`https://smile-msg.zeabur.app`）
