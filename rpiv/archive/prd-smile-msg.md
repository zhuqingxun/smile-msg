---
description: "产品需求文档: SmileMsg - 桌面端即时通讯软件"
status: archived
created_at: 2026-01-29T12:00:00
updated_at: 2026-01-30T00:35:00
archived_at: 2026-01-30T00:35:00
---

# SmileMsg 产品需求文档

## 1. 执行摘要

SmileMsg 是一款轻量级即时通讯工具，核心理念为 **"阅后即焚、无痕沟通、极简易用"**。所有消息数据仅存在于服务器内存中，服务器重启即彻底清零，不连接任何持久化存储。

产品采用 Client-Server 架构，服务端部署在 Zeabur 云平台提供公网 WebSocket 服务。客户端提供两种使用方式：
1. **Windows 桌面端**：Electron 封装的 `.exe` 可执行文件，支持系统托盘等桌面特性
2. **Web 端**：浏览器直接访问服务器地址即可使用，无需安装

两端共享同一套 Vue 前端代码，聊天逻辑完全一致。用户无需注册、无需密码，输入自己昵称登录，再输入对方昵称即可建立一对一私聊。桌面端和 Web 端用户可以互相聊天。

MVP 目标是在 10 人以内的小团队场景下，提供一个开箱即用、零配置、无痕迹的沟通工具。

## 2. 使命

### 使命声明

让小团队拥有一个"用完即走、不留痕迹"的即时沟通工具。

### 核心原则

1. **零持久化（No Persistence）**：服务端严禁连接任何数据库，所有数据仅保存在 RAM 中，进程结束即彻底消失
2. **极简易用（Low Friction）**：无注册、无密码、无配置，输入昵称即用
3. **阅后即焚（Ephemeral）**：消息仅在内存中临时缓存，不留任何持久痕迹
4. **轻量部署（Simplicity）**：桌面端一个 `.exe` 文件，Web 端打开浏览器即用，服务端一键部署到 PaaS

## 3. 目标用户

### 主要用户角色

- **小团队成员**：3-10 人的项目组、工作室、游戏团队等，需要一个不留记录的临时沟通渠道
- **技术舒适度**：基本的电脑操作能力，能运行 `.exe` 文件或打开浏览器即可

### 关键用户需求

- 不希望聊天记录被存储或泄露
- 需要一个比微信/钉钉更轻量的沟通方式
- 不想经历注册、登录、加好友等繁琐流程
- 需要和特定的人快速私聊

### 用户痛点

- 主流 IM 都会持久化存储聊天记录，存在隐私隐患
- 临时组建的团队不想为短期沟通创建正式的群组
- 使用复杂 IM 工具的部署和配置成本太高

## 4. MVP 范围

### 范围内

**核心功能**
- ✅ 昵称登录（无注册、无密码）
- ✅ 输入对方昵称发起一对一私聊
- ✅ 纯文本消息发送与接收

**管理功能**
- ✅ 服务端管理页面（HTTP），管理员可通过浏览器查看在线用户列表

**技术**
- ✅ 断线自动重连 + 身份恢复（内存中保留 uuid）
- ✅ 昵称重名检测
- ✅ WebSocket 实时双向通信（Socket.io）

**部署**
- ✅ 桌面端打包为 Windows `.exe`
- ✅ Web 端由服务端提供静态文件，浏览器直接访问
- ✅ 服务端部署到 Zeabur
- ✅ 环境变量管理 dev/prod 服务器地址

**桌面端特有行为**
- ✅ 关闭窗口最小化到系统托盘
- ✅ 托盘图标点击恢复窗口
- ✅ 托盘右键菜单（显示主界面、彻底退出）

### 范围外

- ❌ 用户注册/密码登录
- ❌ 数据库持久化存储
- ❌ 多人群聊
- ❌ 客户端在线用户列表
- ❌ 多会话并行切换
- ❌ 上下线系统通知消息
- ❌ 图片/文件/语音消息
- ❌ Emoji 选择器
- ❌ 消息已读回执
- ❌ 端到端加密
- ❌ 消息搜索
- ❌ 房间密码/访问控制
- ❌ macOS/Linux 桌面端
- ❌ 用户头像
- ❌ 消息撤回
- ❌ @ 提及功能
- ❌ 消息通知声音/桌面通知

## 5. 用户故事

### US-1: 快速连接并聊天
> 作为一个团队成员，我想要打开软件（或浏览器）后输入昵称就能开始聊天，以便省去注册和配置的时间。

**示例（桌面端）**：小明打开 SmileMsg.exe，输入自己昵称"小明"登录，输入对方昵称"小红"连接，直接进入聊天。
**示例（Web 端）**：小红在浏览器中打开 `https://smile-msg.zeabur.app`，输入昵称"小红"登录，等待小明发起连接。

### US-2: 换人聊天
> 作为一个在线用户，我想要结束当前聊天后和另一个人聊天。

**示例**：小明正在和小红聊天，点击"断开"按钮，回到登录页面，重新登录后输入对方昵称"小刚"，进入与小刚的聊天。

### US-3: 管理员查看在线用户
> 作为管理员，我想要通过浏览器查看当前在线的所有用户，以便了解系统使用情况。

**示例**：管理员在浏览器中访问 `https://smile-msg.zeabur.app/admin`，看到当前在线用户的昵称列表。

### US-4: 无痕退出
> 作为一个注重隐私的用户，我想要确保服务器不永久存储任何消息，以便我的聊天内容不会被事后追溯。

**示例**：服务器重启后，所有消息和用户数据彻底消失，没有任何数据库或日志留存。

### US-5: 后台常驻（桌面端）
> 作为一个桌面端用户，我想要关闭窗口时软件最小化到系统托盘而非退出，以便随时恢复继续聊天。

**示例**：小明点击窗口 X 按钮，窗口隐藏，托盘区出现 SmileMsg 图标，点击图标窗口恢复。

### US-6: 断线恢复
> 作为一个用户，我想要断网重连后自动恢复身份和会话，以便不需要重新登录。

**示例**：小明的网络短暂中断后恢复，SmileMsg 自动重连服务器，昵称和之前的会话自动恢复。

## 6. 核心架构与模式

### 高级架构

```
┌─────────────────────┐
│   Electron Client   │         ┌──────────────────────────┐
│  ┌───────────────┐  │  WSS    │     Node.js Server       │
│  │  Vue 3 (Vite) │◄─┼────────┤  ┌────────────────────┐  │
│  └───────────────┘  │         │  │   Socket.io Server │  │
│  ┌───────────────┐  │         │  └────────────────────┘  │
│  │ Electron Main │  │         │  ┌────────────────────┐  │
│  │ (Tray/Window) │  │         │  │  In-Memory Store    │  │
│  └───────────────┘  │         │  │  - users            │  │
└─────────────────────┘         │  │  - conversations    │  │
                                │  └────────────────────┘  │
┌─────────────────────┐         │  ┌────────────────────┐  │
│    Web Client       │  WSS    │  │  Static Files       │  │
│  ┌───────────────┐  │         │  │  (Vue 构建产物)      │  │
│  │  Vue 3 (同源) │◄─┼────────┤  └────────────────────┘  │
│  └───────────────┘  │         └──────────────────────────┘
│  浏览器              │                 Zeabur PaaS
└─────────────────────┘
```

两端共享同一套 Vue 前端代码。服务端托管 Vue 构建后的静态文件，浏览器访问服务器根路径即可使用 Web 端。

### 目录结构

```
smile-msg/
├── rpiv/                       # 过程文档
│   └── requirements/
├── client/                     # Electron + Vue 客户端
│   ├── src/
│   │   ├── main/               # Electron 主进程
│   │   │   └── index.js        # 窗口管理、托盘逻辑
│   │   └── renderer/           # Vue 渲染进程
│   │       ├── App.vue
│   │       ├── main.js
│   │       ├── components/     # Vue 组件
│   │       ├── composables/    # 组合式函数
│   │       └── assets/         # 静态资源
│   ├── public/
│   ├── index.html
│   ├── vite.config.js
│   ├── electron-builder.yml
│   └── package.json
├── server/                     # Socket.io 服务端
│   ├── index.js                # 入口文件
│   ├── store.js                # 内存数据存储
│   ├── handlers/               # Socket 事件处理器
│   └── package.json
├── .env.development            # 开发环境变量
├── .env.production             # 生产环境变量
└── package.json                # 根 package.json（workspace）
```

### 关键设计模式

1. **事件驱动架构**：客户端与服务端通过 Socket.io 事件进行通信，所有交互基于事件发布/订阅模型
2. **内存数据存储**：服务端使用 JavaScript 原生数据结构（Map、Array）管理所有数据，无任何持久化层
3. **UUID 身份标识**：客户端生成 UUID 保存在内存中，作为本次会话的唯一标识（跨重连不变），与昵称绑定

## 7. 功能规范

### 7.1 客户端界面总览

客户端为单页面应用，包含三个阶段，共两个页面视图：

- **阶段一（登录阶段）**：登录页面 — 输入自己昵称，登录服务器
- **阶段二（空闲阶段）**：聊天页面 — 已登录，未连接对方，可输入对方昵称发起连接；也可被他人主动连接
- **阶段三（聊天阶段）**：聊天页面 — 已连接对方，正常收发消息

```
┌─────────────────────────────────────┐
│          阶段一：登录页面             │
│                                     │
│         SmileMsg                    │
│                                     │
│       我的昵称: [___________]       │
│       错误提示（红字）               │
│                                     │
│         [ 登录 / 登录中... ]        │
│                                     │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│    阶段二/三：聊天页面               │
│                                     │
│  ┌─────────────────────────────────┐│
│  │ [对方昵称输入框] [连接]  ← 空闲  ││
│  │  或                              ││
│  │  对方昵称         [断开]  ← 聊天  ││
│  ├─────────────────────────────────┤│
│  │                                 ││
│  │  （空闲阶段：纯空白）            ││
│  │                                 ││
│  │  （聊天阶段：消息气泡）          ││
│  │  ┌──────────┐                   ││
│  │  │ 对方消息  │                   ││
│  │  └──────────┘                   ││
│  │                   ┌──────────┐  ││
│  │                   │ 我的消息  │  ││
│  │                   └──────────┘  ││
│  │                                 ││
│  │  ── 对方已离线 ──               ││
│  │                                 ││
│  ├─────────────────────────────────┤│
│  │ [消息输入框（空闲时禁用）]       ││
│  │                   (Enter发送)    ││
│  └─────────────────────────────────┘│
└─────────────────────────────────────┘
```

**窗口属性：**
- 默认大小：有合理的默认尺寸
- 用户可自由拖拽调整窗口大小
- 视觉风格：简约白色系（白色背景、浅灰边框、蓝色强调色）

### 7.2 阶段一：登录

**界面：** 全屏简洁式布局，昵称输入框和登录按钮居中摆放，无卡片容器。

**界面元素：**
- 应用名称标题
- **昵称输入框**：用户输入自己的昵称
- **登录按钮**：点击后登录服务器
- **错误提示**：输入框下方红色文字

**输入验证：**
- 昵称长度：1-20 个字符，不可为空
- 不记住历史输入（每次打开或返回到此页面时清空）

**登录流程：**
1. 用户输入昵称，点击"登录"
2. 按钮变为 loading 状态（显示"登录中..."，禁止重复点击）
3. 客户端生成 UUID（内存中保存），发送 `login` 事件携带 `{uuid, nickname}`
4. 服务端检查：
   - 该 UUID 已在线 → 踢掉旧连接，新连接接管身份
   - 该昵称被其他 UUID 占用 → 返回错误"昵称已被使用"→ 输入框下方显示红字
5. 登录成功 → 切换到聊天页面（阶段二：空闲阶段）

### 7.3 阶段二：空闲（已登录，未连接对方）

**顶部区域：**
- 对方昵称输入框（1-20 字符）
- "连接"按钮
- 输入框下方可显示错误提示（红字）

**消息区域：** 纯空白，不显示任何内容。

**消息输入框：** 禁用状态，不可输入。

**主动发起连接流程：**
1. 用户输入对方昵称，点击"连接"
2. 按钮变为 loading 状态（显示"连接中..."）
3. 发送 `create_private_chat` 事件携带 `{targetNickname}`
4. 服务端检查对方状态：
   - 对方不在线 → 返回"该用户不在线"→ 输入框下方红字提示
   - 对方正在和别人聊天 → 返回"对方正忙"→ 输入框下方红字提示
   - 对方在线且空闲 → 连接成功，双方进入阶段三（聊天阶段）

**被动接收连接：**
- 当他人主动向自己发起私聊时，服务端发送 `conversation_created` 事件
- 客户端自动从空闲阶段切换到聊天阶段（无需确认）
- 顶部输入框区域被替换为聊天顶部栏

### 7.4 阶段三：聊天（已连接对方）

**顶部栏（替换空闲阶段的输入框区域）：**
- 显示对方昵称
- "断开"按钮

**消息区域：**
- 自己发的消息：右侧蓝色气泡
- 对方消息：左侧白色/浅灰气泡
- 不显示发送时间
- 新消息到达时始终自动滚动到底部
- 客户端最多保留 200 条消息，超出淘汰最早的

**消息输入：**
- 切换到聊天阶段后，输入框变为可用状态
- Enter 键发送消息，Shift+Enter 换行
- 输入内容为空（只有空格或换行）时禁止发送

**断开操作：**
- 点击"断开"按钮 → 断开 WebSocket 连接（登出）→ 回到阶段一（登录页面）
- 聊天记录清空

**对方下线处理：**
- 聊天区域显示"对方已离线"提示
- 消息输入框变为禁用状态，无法继续发送
- 用户需点击"断开"回到登录页面

### 7.5 断线重连

- Socket.io 内置自动重连机制
- 重连时携带内存中的 UUID 和昵称
- 服务端识别 UUID 后恢复用户身份，重新加入之前的会话
- 重连成功后自动恢复聊天阶段（如果对方仍在线）
- 客户端侧的消息记录在断线期间保留在 Vue 组件状态中

### 7.6 管理员页面

- 服务端提供 HTTP 页面（路径：`/admin`）
- 显示当前所有在线用户的昵称列表
- 页面自动刷新或手动刷新获取最新数据
- 无需身份验证（MVP 阶段，依赖 URL 不公开作为基本保护）

### 7.7 客户端平台差异

**桌面端（Electron）特有行为：**
- 关闭按钮（X）→ 隐藏窗口，最小化到系统托盘
- 系统托盘图标 → 单击恢复窗口
- 托盘右键菜单：
  - "显示主界面" → 恢复窗口
  - "彻底退出" → 断开连接，关闭进程

**Web 端行为：**
- 浏览器访问服务器根路径（如 `https://smile-msg.zeabur.app`）即可使用
- 关闭浏览器标签页 = 断开连接（登出）
- 无系统托盘功能
- 其余聊天逻辑（三阶段交互、消息收发、断线重连等）与桌面端完全一致

## 8. 技术栈

### 客户端

| 技术 | 版本 | 用途 |
|------|------|------|
| Electron | ≥28 | 桌面应用外壳、窗口管理、系统托盘 |
| Vue 3 | ≥3.4 | 前端 UI 框架（Composition API） |
| Vite | ≥5 | 前端构建工具 |
| Tailwind CSS | ≥3 | UI 样式 |
| socket.io-client | ≥4 | WebSocket 客户端 |
| electron-builder | ≥24 | 打包为 Windows .exe |

### 服务端

| 技术 | 版本 | 用途 |
|------|------|------|
| Node.js | ≥18 | 运行环境 |
| Socket.io | ≥4 | WebSocket 服务端 |
| Express | ≥4 | HTTP 服务（静态文件托管、管理页面、健康检查） |

### 开发依赖

| 工具 | 用途 |
|------|------|
| concurrently | 同时启动 client 和 server 开发服务 |
| dotenv | 环境变量管理（服务端） |

## 9. 安全与配置

### 身份验证

- MVP 无身份验证系统
- 用户通过昵称 + 客户端生成的 UUID 识别
- UUID 不具备密码学安全性，仅用于会话恢复

### 配置管理

**客户端环境变量（Vite .env 文件）：**

```
# .env.development
VITE_SERVER_URL=http://localhost:3000

# .env.production
VITE_SERVER_URL=https://smile-msg.zeabur.app
```

**服务端环境变量：**

```
PORT=3000                    # 服务端口
NODE_ENV=production          # 运行环境
```

### 安全范围

**范围内：**
- ✅ 昵称重名检测（防止冒充）
- ✅ UUID 身份绑定（防止会话劫持的基本措施）
- ✅ HTTPS/WSS 传输加密（Zeabur 自动提供）

**范围外：**
- ❌ 端到端加密
- ❌ 消息内容审查
- ❌ 速率限制/防刷
- ❌ IP 白名单

### 部署

- **平台**：Zeabur
- **协议**：HTTPS + WSS（Zeabur 自动提供 SSL 证书）
- **域名**：使用 Zeabur 提供的子域名（如 `smile-msg.zeabur.app`）

## 10. API 规范（Socket.io 事件）

### 客户端 → 服务端事件

#### `login`
```json
{
  "uuid": "550e8400-e29b-41d4-a716-446655440000",
  "nickname": "小明"
}
```
**响应回调：**
```json
// 成功
{
  "success": true
}

// 失败
{
  "success": false,
  "error": "昵称已被使用"
}
```

#### `send_message`
```json
{
  "conversationId": "conv_xxx",
  "content": "你好！"
}
```

#### `create_private_chat`
```json
{
  "targetNickname": "小红"
}
```
**响应回调：**
```json
// 成功
{
  "success": true,
  "conversationId": "conv_xxx",
  "target": {"uuid": "...", "nickname": "小红"}
}

// 失败
{
  "success": false,
  "error": "该用户不在线"  // 或 "对方正忙"
}
```

### 服务端 → 客户端事件

#### `new_message`
```json
{
  "conversationId": "conv_xxx",
  "message": {
    "id": "msg_xxx",
    "senderUuid": "...",
    "senderNickname": "小明",
    "content": "你好！",
    "timestamp": 1706500000000,
    "type": "text"
  }
}
```

#### `conversation_created`
（当被他人发起私聊时收到，客户端自动从连接阶段切换到聊天阶段）
```json
{
  "conversationId": "conv_xxx",
  "target": {"uuid": "...", "nickname": "小明"}
}
```

#### `peer_offline`
（当聊天对方下线时收到）
```json
{
  "conversationId": "conv_xxx"
}
```

### HTTP API（管理功能）

#### `GET /admin`
返回一个简单的 HTML 页面，显示当前在线用户的昵称列表。

## 11. 成功标准

### MVP 成功定义

SmileMsg MVP 在以下条件全部满足时视为成功：

### 功能要求

- ✅ 用户可通过昵称登录，无需注册
- ✅ 输入对方昵称发起私聊，正常收发消息
- ✅ Web 端浏览器访问即可使用，与桌面端互通
- ✅ 管理员可通过浏览器查看在线用户列表
- ✅ 断线重连后身份自动恢复
- ✅ 桌面端关闭窗口最小化到托盘
- ✅ 服务器重启后所有数据清零

### 质量指标

- 消息发送延迟 < 500ms（正常网络条件下）
- 客户端内存占用 < 200MB
- 支持 10 人同时在线无明显卡顿

### 用户体验目标

- 从打开客户端（`.exe` 或浏览器）到发送第一条消息 < 10 秒
- UI 布局直观，无需使用说明

## 12. 实施阶段

### 阶段一：项目脚手架与服务端核心

**目标**：搭建项目结构，实现服务端核心通信能力。

- ✅ 初始化 monorepo 结构（client + server）
- ✅ 服务端 Socket.io 基础搭建
- ✅ 内存数据存储模块（用户管理、会话管理）
- ✅ 登录/登出事件处理
- ✅ 按昵称查找用户并建立私聊
- ✅ 私聊消息收发
- ✅ 管理员页面（`/admin`，显示在线用户列表）

**验证**：用 Socket.io 测试客户端手动验证所有事件正常工作；浏览器访问 `/admin` 验证管理页面。

### 阶段二：客户端 UI（Vue Web 应用）

**目标**：实现完整的 Vue 3 前端界面，作为 Web 端直接可用。

- ✅ Vite + Vue 3 + Tailwind CSS 项目搭建
- ✅ 登录界面
- ✅ 聊天主界面布局（三阶段交互）
- ✅ 输入昵称发起私聊交互
- ✅ 消息气泡（自己/他人）
- ✅ 消息输入与发送
- ✅ 断线重连与身份恢复
- ✅ 服务端托管 Vue 构建产物（静态文件），浏览器访问根路径即可使用

**验证**：在浏览器中完整测试所有 UI 交互和聊天功能（Web 端验证）。

### 阶段三：Electron 桌面端集成

**目标**：将 Vue 应用封装到 Electron 中，实现桌面端特有功能。

- ✅ Electron 主进程搭建
- ✅ 加载 Vue 应用（开发模式 + 生产模式）
- ✅ 系统托盘功能
- ✅ 关闭窗口行为（最小化到托盘）
- ✅ electron-builder 打包配置
- ✅ 生成 Windows `.exe` 安装包

**验证**：在 Windows 上安装 `.exe` 并进行完整功能测试。

### 阶段四：部署与联调

**目标**：部署到 Zeabur 并完成端到端验证。

- ✅ 服务端部署到 Zeabur
- ✅ 配置生产环境变量
- ✅ Web 端浏览器访问测试
- ✅ 桌面端连接生产服务器测试
- ✅ 多用户联调（2-3 人同时在线，桌面端与 Web 端互通测试）
- ✅ 打包最终版 `.exe`

**验证**：至少 2 人分别使用桌面端 `.exe` 和 Web 端浏览器连接云端服务器，完成跨端私聊的完整流程。

## 13. 未来考虑

### MVP 后增强

- **客户端在线用户列表**：在客户端显示在线用户，点击直接发起聊天
- **多会话并行**：同时维护多个私聊会话并自由切换
- **上下线系统通知**：在聊天界面显示用户上下线通知消息
- **历史消息缓存**：服务端缓存每会话最新消息，用户打开会话时自动拉取
- **多人群聊**：从在线用户中选人创建群聊，支持群内消息广播
- **消息类型扩展**：图片（Base64）、文件传输、Emoji 选择器
- **消息通知**：桌面通知弹窗、新消息提示音
- **消息撤回**：发送后 2 分钟内可撤回
- **@ 提及**：群聊中 @ 特定成员
- **已读回执**：显示消息是否被对方阅读

### 集成机会

- **自动更新**：Electron auto-updater 实现客户端自动升级
- **跨平台桌面端**：macOS / Linux 桌面端
- **移动端优化**：Web 端的移动端响应式适配

### 高级功能

- **端到端加密**：基于 Signal Protocol 的消息加密
- **房间密码**：访问控制机制
- **管理员角色**：踢人、禁言等管理能力
- **消息搜索**：客户端本地搜索当前缓存的消息

## 14. 风险与缓解措施

| 风险 | 影响 | 缓解策略 |
|------|------|----------|
| **Zeabur 服务重启导致数据丢失** | 所有在线用户断线、消息清零 | 这是设计预期行为；客户端自动重连后恢复身份，用户重新进入即可 |
| **昵称冒充** | 无密码保护，任何人可以使用任意昵称 | MVP 阶段可接受：面向小团队内部使用；后续可增加密码或邀请码机制 |
| **Electron 包体积过大** | Windows `.exe` 可能达到 80-150MB | 使用 electron-builder 的 asar 压缩；考虑后续迁移到 Tauri 减小体积 |
| **WebSocket 连接不稳定** | 弱网环境下消息丢失 | Socket.io 内置重连机制 |

## 15. 附录

### 关键依赖

| 依赖 | 链接 |
|------|------|
| Electron | https://www.electronjs.org/ |
| Vue 3 | https://vuejs.org/ |
| Vite | https://vitejs.dev/ |
| Socket.io | https://socket.io/ |
| Tailwind CSS | https://tailwindcss.com/ |
| electron-builder | https://www.electron.build/ |
| Zeabur | https://zeabur.com/ |

### 服务端内存数据结构示意

```javascript
// 在线用户表
const users = new Map();
// key: uuid, value: { socketId, nickname, conversationIds: Set }

// 会话表（仅私聊）
const conversations = new Map();
// key: conversationId, value: { members: Set<uuid> }

// Socket 映射（用于快速查找）
const socketToUser = new Map();
// key: socketId, value: uuid
```
